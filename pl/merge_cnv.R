library(plyr, quietly = TRUE, warn.conflicts = FALSE)
library(dplyr, quietly = TRUE, warn.conflicts = FALSE)
library(tidyr, quietly = TRUE, warn.conflicts = FALSE)
library(stats, quietly = TRUE, warn.conflicts = FALSE)
library(zoo, quietly = TRUE, warn.conflicts = FALSE)
library(RPostgreSQL, quietly = TRUE, warn.conflicts = FALSE)

# a rough filter by eye to remove high variance regions
# drop if variance of median CN over 9 windows is > 0.3 or a window's median is > 3 
median.win <- 10
median.var.max <- 0.3
median.max <- 3

cmd.args <- commandArgs(trailingOnly = TRUE)

 # Sys.setenv(PGHOST="localhost",PGUSER="dkulp",PGDATABASE="seq")
 # cmd.args <- c("/cygwin64/home/dkulp/data/out/cnv_seg.B12.L500.Q13.3/windows.vcf.gz.txt",'0.80','20','5',"/cygwin64/home/dkulp/data/out/cnv_seg.B12.L500.Q13.3/sites_cnv_segs.txt.debug")
# cmd.args <- c("/home/unix/dkulp/data/out/1Apr2017_binspace/data_sfari_batch1C_1Apr2017_binspaceb/B12.L5.Q13.W10.PB0.7.ML2400/windows.vcf.gz.txt","0.80","13","5","/home/unix/dkulp/data/out/1Apr2017_binspace/data_sfari_batch1A_1Apr2017_binspaceb/B12.L5.Q13.W10.PB0.7.ML2400/sites_cnv_segs.txt")
cnv.geno.fn <- cmd.args[1]
pass.thresh <- as.numeric(cmd.args[2])  # e.g. .80. Drop sites entirely if less than pass.thresh % of samples have FT ("per-sample genotype filter") of PASS
qual.thresh <- as.numeric(cmd.args[3]) 		# CNQ phred-style threshold, e.g. 20
max.join <- as.numeric(cmd.args[4])  # size (in bins) of runs to span if flanking calls are the same, e.g. 5
cnv.seg.fn <- cmd.args[5]   # a delimited "site" output file of putative regions
extend.qual.thresh <- as.numeric(cmd.args[6])

#################################################################################################
# PROCESS genotyper as above
# file is generated by vcf2tab and is of form:
# BIN CHR START   END PASS X09C81182 X09C81377 ... X09C81182_CNQ X09C81377_CNQ
message(sprintf("%s: Reading %s", Sys.time(), cnv.geno.fn)); message(sprintf("%s: Reading %s", Sys.time(), cnv.geno.fn)) 

cnv.geno <- read.table(cnv.geno.fn, stringsAsFactors = FALSE, header=TRUE, check.names = FALSE)

# there are 5 site info columns followed by calls and quality per sample
sample.count <- (ncol(cnv.geno)-5)/2
message(sprintf("%s: Read %s samples at %s sites", Sys.time(), sample.count, nrow(cnv.geno)))

# set the genotype values as numeric
for (s in 6:(5+sample.count)) {
  cnv.geno[,s] <- as.numeric(cnv.geno[,s])
}

low.qual <- rep(0,sample.count)
cnq.cols <- (ncol(cnv.geno)-sample.count+1):ncol(cnv.geno)
cat(sprintf("Setting CNQ=0 for all samples of low call rate (<%s) (%s sites)\n", pass.thresh,
            length(which(cnv.geno$PASS/sample.count < pass.thresh))))
cnv.geno <- cnv.geno[cnv.geno$PASS/sample.count > pass.thresh,]
cnv.geno[cnv.geno$PASS/sample.count < pass.thresh,cnq.cols] <- low.qual

message(Sys.time(), ": Computing median per site")
cnv.geno$site.median = apply(cnv.geno[,6:(5+sample.count)], 1, median, na.rm=TRUE)

message(sprintf("%s: Computing variance of median on rolling windows of length %s",Sys.time(), median.win))
cnv.geno$site.median.var <- c(rep(0,median.win/2),
                              rollapply(cnv.geno$site.median, width=median.win, var, na.rm=TRUE),
                              rep(0,median.win/2-1))
message(sprintf("%s: Setting CNQ=0 for all samples with variance > %s (%s sites)", Sys.time(), median.var.max, 
            sum(cnv.geno$site.median.var>median.var.max, na.rm=TRUE)))
cnv.geno[cnv.geno$site.median.var > median.var.max,cnq.cols] <- low.qual

message(sprintf("%s: Setting CNQ=0 for all samples with median CN > %s (%s sites)", Sys.time(), median.max, sum(cnv.geno$site.median > median.max, na.rm=TRUE)))
cnv.geno[is.na(cnv.geno$site.median) | cnv.geno$site.median > median.max, cnq.cols] <- low.qual

# evaluate as rows and recover base positions later
pos.map <- cnv.geno[,1:4]
pos.map$CENTER <- floor(pos.map$START + (pos.map$END-pos.map$START)/2)
pos.map$BIN.SIZE <- c(pos.map$CENTER[2:nrow(pos.map)] - pos.map$CENTER[1:(nrow(pos.map)-1)],0)

# replace calls with NA if below quality threshold
message(sprintf("%s: Setting calls with CNQ <= %s to NA", Sys.time(), qual.thresh))
for (i in 6:(6+sample.count-1)) {
  cnv.geno[,i] <- ifelse(cnv.geno[,i+sample.count]>qual.thresh,cnv.geno[,i],NA)
}
NA.calls <- sum(is.na(cnv.geno[,6:(5+sample.count)]))
message(sprintf("%s: Removed %s/%s = %s%% calls", Sys.time(), NA.calls, sample.count*nrow(cnv.geno), NA.calls/sample.count/nrow(cnv.geno)*100))

# generate consecutive runs per sample
t1.fn <- tempfile("cnv")
t1.conn <- file(t1.fn,"w")
cat(".id,cn,start,end\n",file=t1.conn)
message(sprintf("%s: Merging runs of same CN in temp file %s",Sys.time(), t1.fn))
for (s in 6:(5+sample.count)) {
  copyNumber <- cnv.geno[,s]
  sample.name <- colnames(cnv.geno)[s]
  cat(sprintf("%s:%s ",s-5,sample.name), file=stderr())

  pos.i <- 1
  for (i in pos.i+1:(length(copyNumber)-1)) {
    if (!(identical(copyNumber[i],copyNumber[pos.i]))) {
      # a change in the CNV, so add this cnv and reseti<- pos.i
      cat(paste(sample.name,copyNumber[pos.i],pos.i, i-1,sep=','),"\n",file=t1.conn)
      pos.i <- i
    }
  }
  cat(paste(sample.name,cn=copyNumber[pos.i],pos.i, end=length(copyNumber),sep=','),"\n",file=t1.conn)
}
close(t1.conn)
cat("\n",file=stderr())
message(sprintf("%s: Loading %s into cn.segs",Sys.time(), t1.fn))
cn.segs <- read.csv(t1.fn, as.is=TRUE, check.names=FALSE)
message(sprintf("%s: Read %s rows",Sys.time(), nrow(cn.segs)))

# add actual nt positions
cn.segs$chr <- pos.map[cn.segs$start,'CHR']
cn.segs$start.map <- pos.map[cn.segs$start,'CENTER']
cn.segs$end.map <- pos.map[cn.segs$end,'CENTER']+pos.map[cn.segs$end,'BIN.SIZE']
cn.segs$copy.number <- addNA(as.factor(cn.segs$cn))

# record BIN number (which is different from row index!)
cn.segs$start.bin <- pos.map[cn.segs$start,'BIN']
cn.segs$end.bin <- pos.map[cn.segs$end,'BIN']


# merge small calls between common CN
message(sprintf("%s: Joining segments across small (%s bin) segments", Sys.time(), max.join))
new.extents <-
  ddply(cn.segs, .(.id), function(cs) {
    cat(cs$.id[1],"\n")
    
    new.adj <- rep(NA,nrow(cs))
    i <- i2 <- 1  # i is the left-most extent and i2 is the right-most extent of the same cn
    cn.i <- cs$copy.number[i]
    end.bin.i <- cs$end.bin[i]
    j <- i+1
    while (j <= nrow(cs)) {
      if (cs$start.bin[j]-end.bin.i > max.join) {
        new.adj[i] <- i2
        i <- i2+1
        i2 <- i
        cn.i <- cs$copy.number[i]
        end.bin.i <- cs$end.bin[i]
        j <- i
      } else if (cs$copy.number[j]==cn.i) {
        end.bin.i <- cs$end.bin[j] # new rightmost position of current copy number extent
        i2 <- j
      }
      j <- j + 1
    }
    
    # The start's are the indices of cs, which are the non-NA elements of new.adj
    start.i <- which(!is.na(new.adj))
    
    # The end's are the indices of cs corresponding to the adjacent contig or the end of a thread if i==new.adj[i]
    end.i <- new.adj[start.i]
    
    cn <- cs$cn[start.i]
    chr <- cs$chr[start.i]
    
    start.map <- cs$start.map[start.i]
    start.bin <- cs$start.bin[start.i]
    end.map <- cs$end.map[end.i]
    end.bin <- cs$end.bin[end.i]
    
    return(data.frame(cn, start.i, end.i, chr, start.map, end.map, start.bin, end.bin))
  })

# use new.extents to dereference cn.segs and create a new (condensed) set
cn.segs.merged <- mutate(new.extents,
                         copy.number=addNA(as.factor(cn)),
                         len=end.map-start.map,
                         seg=sprintf("SEG_%s_%s_%s", chr, start.map, end.map))
cn.segs.merged$len2 <- c(cn.segs.merged$start.map[2:nrow(cn.segs.merged)]-cn.segs.merged$start.map[1:(nrow(cn.segs.merged)-1)],0)
cn.segs.merged$gap <- c(cn.segs.merged$start.map[2:nrow(cn.segs.merged)]-cn.segs.merged$end.map[1:(nrow(cn.segs.merged)-1)],0)
# ggplot(subset(cn.segs.merged, copy.number != '2'), aes(y=.id, yend=.id, color=copy.number, x=start.map, xend=end.map)) + geom_segment(size=4)

# generate sites to run through org.broadinstitute.sv.apps.ProfileGenotyper
test.segs <- arrange(unique(cn.segs.merged[!is.na(cn.segs.merged$cn),c('seg','chr','start.map','end.map')]),start.map)
message(sprintf("%s: Writing %s CNV segments to %s",Sys.time(), nrow(test.segs), cnv.seg.fn))
write.table(test.segs, file=cnv.seg.fn, sep="\t", row.names=FALSE, col.names=FALSE, quote=FALSE )

cn.segs.merged <- mutate(cn.segs.merged, label=sprintf("%s_%s",seg,.id))

# save for debugging and later processing
message(sprintf("%s: Writing R objects to %s*.Rdata", Sys.time(), cnv.seg.fn))
save(cn.segs, file=sprintf("%s.cs.Rdata",cnv.seg.fn))
save(cn.segs.merged, file=sprintf("%s.csm.Rdata",cnv.seg.fn))
write.table(select(cn.segs.merged, .id, seg, chr, start.map, end.map, copy.number), file=sprintf("%s.tbl",cnv.seg.fn), sep="\t", row.names=FALSE, col.names=FALSE, quote=FALSE)

message(Sys.time(), ": connecting to db")
db <- src_postgres()
message(Sys.time(), ": Writing cnv_mrg to db")
if (dbExistsTable(db$con, "cnv_mrg")) { dbGetQuery(db$con, "DROP TABLE cnv_mrg") }
dbWriteTable(db$con, "cnv_mrg", select(cn.segs.merged, .id, seg, chr, start.map, end.map, start.bin, end.bin, cn, copy.number))
message(Sys.time(), ": indexing cnv_mrg by start.map and start.bin")
invisible(dbGetQuery(db$con, "CREATE INDEX on cnv_mrg(chr, \"start.map\", \".id\")"))
invisible(dbGetQuery(db$con, "CREATE INDEX on cnv_mrg(chr, \"start.bin\", \".id\")"))

message(Sys.time(),sprintf(": Writing wide-form genotypes to %s.cg.Rdata", cnv.seg.fn))
save(cnv.geno, file=sprintf("%s.cg.Rdata",cnv.seg.fn))

message(Sys.time(), ": making narrow-form genotypes (one row per sample per pos")
cn <- cnv.geno[,c(1:4,6:(5+sample.count))]
cn2 <- gather(cn,sample,cn,-BIN,-CHR,-START,-END)

cnq <- cnv.geno[,c(1:4,(6+sample.count):(ncol(cnv.geno)-2))]
cnq2 <- gather(cnq,sample,cnq,-BIN,-CHR,-START,-END)

cnv.geno <- cbind(cn2, cnq=cnq2$cnq)

colnames(cnv.geno) <- c('bin','chr','start_pos','end_pos', 'sample','cn','cnq')
cnv.geno$bin <- as.integer(cnv.geno$bin)
cnv.geno$chr <- as.character(cnv.geno$chr)
cnv.geno$cn <- as.integer(cnv.geno$cn)

rm(cn,cn2,cnq,cnq2)

cnv.geno.exploded.fn <- sprintf("%s.cnvgeno.txt",cnv.seg.fn)
message(sprintf("%s: Writing %s exploded genotype calls to %s",Sys.time(), nrow(cnv.geno),cnv.geno.exploded.fn))
write.table(cnv.geno, file=cnv.geno.exploded.fn, quote=FALSE, sep="\t", row.names=FALSE)

## message(sprintf("%s: Writing %s exploded genotype calls to db in table geno",Sys.time(), nrow(cnv.geno)))
## if (dbExistsTable(db$con, "geno")) { dbGetQuery(db$con, "DROP TABLE geno") }
## dbWriteTable(db$con, "geno", cnv.geno)
## message(Sys.time(),": indexing geno")
## dbGetQuery(db$con, "CREATE UNIQUE INDEX on geno(chr, bin, sample)")

rm(db)
message(Sys.time(),": Done.")
